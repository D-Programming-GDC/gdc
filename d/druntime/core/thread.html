<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>core.thread</title>
	</head><body>
	<h1>core.thread</h1>
	<!-- Generated by Ddoc from core\thread.d -->
$(DDOC_SECTIONS 
The <u>thread</u> module provides support for <u>thread</u> creation and management.
<br><br>
$(DDOC_LICENSE <a href="http://www.boost.org/LICENSE_1_0.txt>Boost License 1.0</a>.
)
<b>Authors:</b><br>
Sean Kelly
<br><br>

          Copyright Sean Kelly 2005 - 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
)
<b>http:</b><br>
//www.boost.org/LICENSE_1_0.txt<br><br>
 
<br><br>
)
<dl><dt><big>class <u>ThreadException</u>: object.Exception;
</big></dt>
<dd>Base class for thread exceptions.
 
<br><br>

</dd>
<dt><big>class <u>FiberException</u>: object.Exception;
</big></dt>
<dd>Base class for fiber exceptions.
 
<br><br>

</dd>
<dt><big>alias <u>btex_fptr</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>class <u>Thread</u>;
</big></dt>
<dd>This class encapsulates all threading functionality for the D
 programming language.  As thread manipulation is a required facility
 for garbage collection, all user threads should derive from this
 class, and instances of this class should never be explicitly deleted.
 A new thread may be created using either derivation or composition, as
 in the following example.
<br><br>
<b>Example:</b><br>
<pre class="d_code">
 <font color=blue>class</font> DerivedThread : <u>Thread</u>
 {
     <font color=blue>this</font>()
     {
         <font color=blue>super</font>( &amp;run );
     }

 <font color=blue>private</font> :
     <font color=blue>void</font> run()
     {
         printf( <font color=red>"Derived thread running.\n"</font> );
     }
 }

 <font color=blue>void</font> threadFunc()
 {
     printf( <font color=red>"Composed thread running.\n"</font> );
 }

 <font color=green>// create instances of each type
</font> <u>Thread</u> derived = <font color=blue>new</font> DerivedThread();
 <u>Thread</u> composed = <font color=blue>new</font> <u>Thread</u>( &amp;threadFunc );

 <font color=green>// start both threads
</font> derived.start();
 composed.start();

</pre>
 
<br><br>

<dl><dt><big>this(void function() <i>fn</i>, size_t <i>sz</i> = 0);
</big></dt>
<dd>Initializes a thread object which is associated with a static
 D function.
<br><br>
<b>Params:</b><br>
<table><tr><td>void function() <i>fn</i></td>
<td>The thread function.</td></tr>
<tr><td>size_t <i>sz</i></td>
<td>The stack size for this thread.</td></tr>
</table><br>
<b>In:</b><br>
<i>fn</i> must not be <b>null</b>.
     
<br><br>

</dd>
<dt><big>this(void delegate() <i>dg</i>, size_t <i>sz</i> = 0);
</big></dt>
<dd>Initializes a thread object which is associated with a dynamic
 D function.
<br><br>
<b>Params:</b><br>
<table><tr><td>void delegate() <i>dg</i></td>
<td>The thread function.</td></tr>
<tr><td>size_t <i>sz</i></td>
<td>The stack size for this thread.</td></tr>
</table><br>
<b>In:</b><br>
<i>dg</i> must not be <b>null</b>.
     
<br><br>

</dd>
<dt><big>final void <u>start</u>();
</big></dt>
<dd>Starts the thread and invokes the function or delegate passed upon
 construction.
<br><br>
<b>In:</b><br>
This routine may only be called once per thread instance.

<br><br>
<b>Throws:</b><br>
ThreadException if the thread fails to <u>start</u>.
     
<br><br>

</dd>
<dt><big>final Object <u>join</u>(bool <i>rethrow</i> = true);
</big></dt>
<dd>Waits for this thread to complete.  If the thread terminated as the
 result of an unhandled exception, this exception will be rethrown.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>rethrow</i></td>
<td>Rethrow any unhandled exception which may have caused this
            thread to terminate.</td></tr>
</table><br>
<b>Throws:</b><br>
ThreadException if the operation fails.
  Any exception not handled by the joined thread.

<br><br>
<b>Returns:</b><br>
Any exception not handled by this thread if <i>rethrow</i> = <b>false</b>, <b>null</b>
  otherwise.
     
<br><br>

</dd>
<dt><big>final char[] <u>name</u>();
</big></dt>
<dd>Gets the user-readable label for this thread.
<br><br>
<b>Returns:</b><br>
The <u>name</u> of this thread.
     
<br><br>

</dd>
<dt><big>final void <u>name</u>(char[] <i>val</i>);
</big></dt>
<dd>Sets the user-readable label for this thread.
<br><br>
<b>Params:</b><br>
<table><tr><td>char[] <i>val</i></td>
<td>The new <u>name</u> of this thread.</td></tr>
</table><br>

</dd>
<dt><big>final bool <u>isDaemon</u>();
</big></dt>
<dd>Gets the daemon status for this thread.  While the runtime will wait for
 all normal threads to complete before tearing down the process, daemon
 threads are effectively ignored and thus will not prevent the process
 from terminating.  In effect, daemon threads will be terminated
 automatically by the OS when the process exits.
<br><br>
<b>Returns:</b><br>
<b>true</b> if this is a daemon thread.
     
<br><br>

</dd>
<dt><big>final void <u>isDaemon</u>(bool <i>val</i>);
</big></dt>
<dd>Sets the daemon status for this thread.  While the runtime will wait for
 all normal threads to complete before tearing down the process, daemon
 threads are effectively ignored and thus will not prevent the process
 from terminating.  In effect, daemon threads will be terminated
 automatically by the OS when the process exits.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>val</i></td>
<td>The new daemon status for this thread.</td></tr>
</table><br>

</dd>
<dt><big>final bool <u>isRunning</u>();
</big></dt>
<dd>Tests whether this thread is running.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the thread is running, <b>false</b> if not.
     
<br><br>

</dd>
<dt><big>static const int <u>PRIORITY_MIN</u>;
</big></dt>
<dd>The minimum scheduling priority that may be set for a thread.  On
 systems where multiple scheduling policies are defined, this value
 represents the minimum valid priority for the scheduling policy of
 the process.
     
<br><br>

</dd>
<dt><big>static const int <u>PRIORITY_MAX</u>;
</big></dt>
<dd>The maximum scheduling priority that may be set for a thread.  On
 systems where multiple scheduling policies are defined, this value
 represents the minimum valid priority for the scheduling policy of
 the process.
     
<br><br>

</dd>
<dt><big>final int <u>priority</u>();
</big></dt>
<dd>Gets the scheduling <u>priority</u> for the associated thread.
<br><br>
<b>Returns:</b><br>
The scheduling <u>priority</u> of this thread.
     
<br><br>

</dd>
<dt><big>final void <u>priority</u>(int <i>val</i>);
</big></dt>
<dd>Sets the scheduling <u>priority</u> for the associated thread.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>val</i></td>
<td>The new scheduling <u>priority</u> of this thread.</td></tr>
</table><br>

</dd>
<dt><big>static void <u>sleep</u>(long <i>period</i>);
</big></dt>
<dd>Suspends the calling thread for at least the supplied <i>period</i>.  This may
 result in multiple OS calls if <i>period</i> is greater than the maximum <u>sleep</u>
 duration supported by the operating system.
<br><br>
<b>Params:</b><br>
<table><tr><td>long <i>period</i></td>
<td>The minimum duration the calling thread should be suspended,
           in 100 nanosecond intervals.</td></tr>
</table><br>
<b>In:</b><br>
<i>period</i> must be non-negative.

<br><br>
<b>Example:</b><br>
<pre class="d_code">
 Thread.<u>sleep</u>( 500_000 );    <font color=green>// sleep for 50 milliseconds
</font> Thread.<u>sleep</u>( 50_000_000 ); <font color=green>// sleep for 5 seconds
</font>
</pre>
     
<br><br>

</dd>
<dt><big>static void <u>yield</u>();
</big></dt>
<dd>Forces a context switch to occur away from the calling thread.
     
<br><br>

</dd>
<dt><big>static Thread <u>getThis</u>();
</big></dt>
<dd>Provides a reference to the calling thread.
<br><br>
<b>Returns:</b><br>
The thread object representing the calling thread.  The result of
  deleting this object is undefined.
     
<br><br>

</dd>
<dt><big>static Thread[] <u>getAll</u>();
</big></dt>
<dd>Provides a list of all threads currently being tracked by the system.
<br><br>
<b>Returns:</b><br>
An array containing references to all threads currently being
  tracked by the system.  The result of deleting any contained
  objects is undefined.
     
<br><br>

</dd>
<dt><big>static int <u>opApply</u>(int delegate(ref Thread) <i>dg</i>);
</big></dt>
<dd>Operates on all threads currently being tracked by the system.  The
 result of deleting any Thread object is undefined.
<br><br>
<b>Params:</b><br>
<table><tr><td>int delegate(ref Thread) <i>dg</i></td>
<td>The supplied code as a delegate.</td></tr>
</table><br>
<b>Returns:</b><br>
Zero if all elemented are visited, nonzero if not.
     
<br><br>

</dd>
<dt><big>static const uint <u>LOCAL_MAX</u>;
</big></dt>
<dd>Indicates the number of local storage pointers available at program
 startup.  It is recommended that this number be at least 64.
     
<br><br>

</dd>
<dt><big>static uint <u>createLocal</u>();
</big></dt>
<dd>Reserves a local storage pointer for use and initializes this location
 to <b>null</b> for all running threads.
<br><br>
<b>Returns:</b><br>
A key representing the array offset of this memory location.
     
<br><br>

</dd>
<dt><big>static void <u>deleteLocal</u>(uint <i>key</i>);
</big></dt>
<dd>Marks the supplied <i>key</i> as available and sets the associated location
 to <b>null</b> for all running threads.  It is assumed that any <i>key</i> passed
 to this function is valid.  The result of calling this function for
 a <i>key</i> which is still in use is undefined.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>key</i></td>
<td>The <i>key</i> to delete.</td></tr>
</table><br>

</dd>
<dt><big>static void* <u>getLocal</u>(uint <i>key</i>);
</big></dt>
<dd>Loads the value stored at <i>key</i> within a thread-local static array.  It is
 assumed that any <i>key</i> passed to this function is valid.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>key</i></td>
<td>The location which holds the desired data.</td></tr>
</table><br>
<b>Returns:</b><br>
The data associated with the supplied <i>key</i>.
     
<br><br>

</dd>
<dt><big>static void* <u>setLocal</u>(uint <i>key</i>, void* <i>val</i>);
</big></dt>
<dd>Stores the supplied value at <i>key</i> within a thread-local static array.  It
 is assumed that any <i>key</i> passed to this function is valid.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>key</i></td>
<td>The location to store the supplied data.</td></tr>
<tr><td>void* <i>val</i></td>
<td>The data to store.</td></tr>
</table><br>
<b>Returns:</b><br>
A copy of the data which has just been stored.
     
<br><br>

</dd>
</dl>
</dd>
<dt><big>void <u>thread_init</u>();
</big></dt>
<dd>Initializes the thread module.  This function must be called by the
 garbage collector on startup and before any other thread routines
 are called.
 
<br><br>

</dd>
<dt><big>void <u>thread_attachThis</u>();
</big></dt>
<dd>Registers the calling thread for use with the D Runtime.  If this routine
 is called for a thread which is already registered, the result is undefined.
 
<br><br>

</dd>
<dt><big>void <u>thread_detachThis</u>();
</big></dt>
<dd>Deregisters the calling thread from use with the runtime.  If this routine
 is called for a thread which is already registered, the result is undefined.
 
<br><br>

</dd>
<dt><big>void <u>thread_joinAll</u>();
</big></dt>
<dd>Joins all non-daemon threads that are currently running.  This is done by
 performing successive scans through the thread list until a scan consists
 of only daemon threads.
 
<br><br>

</dd>
<dt><big>bool <u>thread_needLock</u>();
</big></dt>
<dd>This function is used to determine whether the the process is
 multi-threaded.  Optimizations may only be performed on this
 value if the programmer can guarantee that no path from the
 enclosed code will start a thread.
<br><br>
<b>Returns:</b><br>
True if Thread.start() has been called in this process.
 
<br><br>

</dd>
<dt><big>void <u>thread_suspendAll</u>();
</big></dt>
<dd>Suspend all threads but the calling thread for "stop the world" garbage
 collection runs.  This function may be called multiple times, and must
 be followed by a matching number of calls to thread_resumeAll before
 processing is resumed.
<br><br>
<b>Throws:</b><br>
ThreadException if the suspend operation fails for a running thread.
 
<br><br>

</dd>
<dt><big>void <u>thread_resumeAll</u>();
</big></dt>
<dd>Resume all threads but the calling thread for "stop the world" garbage
 collection runs.  This function must be called once for each preceding
 call to thread_suspendAll before the threads are actually resumed.
<br><br>
<b>In:</b><br>
This routine must be preceded by a call to thread_suspendAll.

<br><br>
<b>Throws:</b><br>
ThreadException if the resume operation fails for a running thread.
 
<br><br>

</dd>
<dt><big>void <u>thread_scanAll</u>(scanAllThreadsFn <i>scan</i>, void* <i>curStackTop</i> = null);
</big></dt>
<dd>The main entry point for garbage collection.  The supplied delegate
 will be passed ranges representing both stack and register values.
<br><br>
<b>Params:</b><br>
<table><tr><td>scanAllThreadsFn <i>scan</i></td>
<td>The scanner function.  It should <i>scan</i> from p1 through p2 - 1.</td></tr>
<tr><td>void* <i>curStackTop</i></td>
<td>An optional pointer to the top of the calling thread's stack.</td></tr>
</table><br>
<b>In:</b><br>
This routine must be preceded by a call to thread_suspendAll.
 
<br><br>

</dd>
<dt><big>class <u>ThreadLocal</u>(T);
</big></dt>
<dd>This class encapsulates the operations required to initialize, access, and
 destroy thread local data.
 
<br><br>

<dl><dt><big>this(T def = T.init);
</big></dt>
<dd>Initializes thread local storage for the indicated value which will be
 initialized to def for all threads.
<br><br>
<b>Params:</b><br>
<table><tr><td>def</td>
<td>The default value to return if no value has been explicitly set.</td></tr>
</table><br>

</dd>
<dt><big>T <u>val</u>();
</big></dt>
<dd>Gets the value last set by the calling thread, or def if no such value
 has been set.
<br><br>
<b>Returns:</b><br>
The stored value or def if no value is stored.
     
<br><br>

</dd>
<dt><big>T <u>val</u>(T <i>newval</i>);
</big></dt>
<dd>Copies <i>newval</i> to a location specific to the calling thread, and returns
 <i>newval</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>T <i>newval</i></td>
<td>The value to set.</td></tr>
</table><br>
<b>Returns:</b><br>
The value passed to this function.
     
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>ThreadGroup</u>;
</big></dt>
<dd>This class is intended to simplify certain common programming techniques.
 
<br><br>

<dl><dt><big>final Thread <u>create</u>(void function() <i>fn</i>);
</big></dt>
<dd>Creates and starts a new Thread object that executes <i>fn</i> and adds it to
 the list of tracked threads.
<br><br>
<b>Params:</b><br>
<table><tr><td>void function() <i>fn</i></td>
<td>The thread function.</td></tr>
</table><br>
<b>Returns:</b><br>
A reference to the newly created thread.
     
<br><br>

</dd>
<dt><big>final Thread <u>create</u>(void delegate() <i>dg</i>);
</big></dt>
<dd>Creates and starts a new Thread object that executes <i>dg</i> and adds it to
 the list of tracked threads.
<br><br>
<b>Params:</b><br>
<table><tr><td>void delegate() <i>dg</i></td>
<td>The thread function.</td></tr>
</table><br>
<b>Returns:</b><br>
A reference to the newly created thread.
     
<br><br>

</dd>
<dt><big>final void <u>add</u>(Thread <i>t</i>);
</big></dt>
<dd>Add <i>t</i> to the list of tracked threads if it is not already being tracked.
<br><br>
<b>Params:</b><br>
<table><tr><td>Thread <i>t</i></td>
<td>The thread to <u>add</u>.</td></tr>
</table><br>
<b>In:</b><br>
<i>t</i> must not be <b>null</b>.
     
<br><br>

</dd>
<dt><big>final void <u>remove</u>(Thread <i>t</i>);
</big></dt>
<dd>Removes <i>t</i> from the list of tracked threads.  No operation will be
 performed if <i>t</i> is not currently being tracked by this object.
<br><br>
<b>Params:</b><br>
<table><tr><td>Thread <i>t</i></td>
<td>The thread to <u>remove</u>.</td></tr>
</table><br>
<b>In:</b><br>
<i>t</i> must not be <b>null</b>.
     
<br><br>

</dd>
<dt><big>final int <u>opApply</u>(int delegate(ref Thread) <i>dg</i>);
</big></dt>
<dd>Operates on all threads currently tracked by this object.
     
<br><br>

</dd>
<dt><big>final void <u>joinAll</u>(bool <i>rethrow</i> = true);
</big></dt>
<dd>Iteratively joins all tracked threads.  This function will block add,
 remove, and opApply until it completes.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>rethrow</i></td>
<td>Rethrow any unhandled exception which may have caused the
            current thread to terminate.</td></tr>
</table><br>
<b>Throws:</b><br>
Any exception not handled by the joined threads.
     
<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Fiber</u>;
</big></dt>
<dd>This class provides a cooperative concurrency mechanism integrated with the
 threading and garbage collection functionality.  Calling a fiber may be
 considered a blocking operation that returns when the fiber yields (via
 <u>Fiber</u>.yield()).  Execution occurs within the context of the calling thread
 so synchronization is not necessary to guarantee memory visibility so long
 as the same thread calls the fiber each time.  Please note that there is no
 requirement that a fiber be bound to one specific thread.  Rather, fibers
 may be freely passed between threads so long as they are not currently
 executing.  Like threads, a new fiber thread may be created using either
 derivation or composition, as in the following example.
<br><br>
<b>Example:</b><br>
<pre class="d_code">
 <font color=blue>class</font> DerivedFiber : <u>Fiber</u>
 {
     <font color=blue>this</font>()
     {
         <font color=blue>super</font>( &amp;run );
     }

 <font color=blue>private</font> :
     <font color=blue>void</font> run()
     {
         printf( <font color=red>"Derived fiber running.\n"</font> );
     }
 }

 <font color=blue>void</font> fiberFunc()
 {
     printf( <font color=red>"Composed fiber running.\n"</font> );
     <u>Fiber</u>.yield();
     printf( <font color=red>"Composed fiber running.\n"</font> );
 }

 <font color=green>// create instances of each type
</font> <u>Fiber</u> derived = <font color=blue>new</font> DerivedFiber();
 <u>Fiber</u> composed = <font color=blue>new</font> <u>Fiber</u>( &amp;fiberFunc );

 <font color=green>// call both fibers once
</font> derived.call();
 composed.call();
 printf( <font color=red>"Execution returned to calling context.\n"</font> );
 composed.call();

 <font color=green>// since each fiber has run to completion, each should have state TERM
</font> <font color=blue>assert</font>( derived.state == <u>Fiber</u>.State.TERM );
 <font color=blue>assert</font>( composed.state == <u>Fiber</u>.State.TERM );

</pre>

<br><br>
<b>Authors:</b><br>
Based on a design by Mikola Lysenko.
 
<br><br>

<dl><dt><big>this(void function() <i>fn</i>, size_t <i>sz</i> = PAGESIZE);
</big></dt>
<dd>Initializes a fiber object which is associated with a static
 D function.
<br><br>
<b>Params:</b><br>
<table><tr><td>void function() <i>fn</i></td>
<td>The thread function.</td></tr>
<tr><td>size_t <i>sz</i></td>
<td>The stack size for this fiber.</td></tr>
</table><br>
<b>In:</b><br>
<i>fn</i> must not be <b>null</b>.
     
<br><br>

</dd>
<dt><big>this(void delegate() <i>dg</i>, size_t <i>sz</i> = PAGESIZE);
</big></dt>
<dd>Initializes a fiber object which is associated with a dynamic
 D function.
<br><br>
<b>Params:</b><br>
<table><tr><td>void delegate() <i>dg</i></td>
<td>The thread function.</td></tr>
<tr><td>size_t <i>sz</i></td>
<td>The stack size for this fiber.</td></tr>
</table><br>
<b>In:</b><br>
<i>dg</i> must not be <b>null</b>.
     
<br><br>

</dd>
<dt><big>final Object <u>call</u>(bool <i>rethrow</i> = true);
</big></dt>
<dd>Transfers execution to this fiber object.  The calling context will be
 suspended until the fiber calls Fiber.yield() or until it terminates
 via an unhandled exception.
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>rethrow</i></td>
<td>Rethrow any unhandled exception which may have caused this
            fiber to terminate.</td></tr>
</table><br>
<b>In:</b><br>
This fiber must be in state HOLD.

<br><br>
<b>Throws:</b><br>
Any exception not handled by the joined thread.

<br><br>
<b>Returns:</b><br>
Any exception not handled by this fiber if <i>rethrow</i> = <b>false</b>, <b>null</b>
  otherwise.
     
<br><br>

</dd>
<dt><big>final void <u>reset</u>();
</big></dt>
<dd>Resets this fiber so that it may be re-used.  This routine may only be
 called for fibers that have terminated, as doing otherwise could result
 in scope-dependent functionality that is not executed.  Stack-based
 classes, for example, may not be cleaned up properly if a fiber is <u>reset</u>
 before it has terminated.
<br><br>
<b>In:</b><br>
This fiber must be in state TERM.
     
<br><br>

</dd>
<dt><big>enum <u>State</u>;
</big></dt>
<dd>A fiber may occupy one of three states: HOLD, EXEC, and TERM.  The HOLD
 state applies to any fiber that is suspended and ready to be called.
 The EXEC state will be set for any fiber that is currently executing.
 And the TERM state is set when a fiber terminates.  Once a fiber
 terminates, it must be reset before it may be called again.
     
<br><br>

<dl><dt><big><u>HOLD</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>EXEC</u></big></dt>
<dd><br><br>
</dd>
<dt><big><u>TERM</u></big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big>final State <u>state</u>();
</big></dt>
<dd>Gets the current <u>state</u> of this fiber.
<br><br>
<b>Returns:</b><br>
The <u>state</u> of this fiber as an enumerated value.
     
<br><br>

</dd>
<dt><big>static void <u>yield</u>();
</big></dt>
<dd>Forces a context switch to occur away from the calling fiber.
     
<br><br>

</dd>
<dt><big>static void <u>yieldAndThrow</u>(Object <i>obj</i>);
</big></dt>
<dd>Forces a context switch to occur away from the calling fiber and then
 throws <i>obj</i> in the calling fiber.
<br><br>
<b>Params:</b><br>
<table><tr><td>Object <i>obj</i></td>
<td>The object to throw.</td></tr>
</table><br>
<b>In:</b><br>
<i>obj</i> must not be <b>null</b>.
     
<br><br>

</dd>
<dt><big>static Fiber <u>getThis</u>();
</big></dt>
<dd>Provides a reference to the calling fiber or <b>null</b> if no fiber is
 currently active.
<br><br>
<b>Returns:</b><br>
The fiber object representing the calling fiber or <b>null</b> if no fiber
  is currently active.  The result of deleting this object is undefined.
     
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright Sean Kelly 2005 - 2009.
</small>
	</body></html>
