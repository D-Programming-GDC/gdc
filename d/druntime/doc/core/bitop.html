<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>core.bitop</title>
	</head><body>
	<h1>core.bitop</h1>
	<!-- Generated by Ddoc from core\bitop.d -->
$(DDOC_SECTIONS 
This module contains a collection of bit-level operations.
<br><br>
$(DDOC_LICENSE <a href="http://www.boost.org/LICENSE_1_0.txt>Boost License 1.0</a>.
)
<b>Authors:</b><br>
Don Clugston, Sean Kelly, Walter Bright
<br><br>

          Copyright Don Clugston 2005 - 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
)
<b>http:</b><br>
//www.boost.org/LICENSE_1_0.txt<br><br>
 
<br><br>
)
<dl><dt><big>int <u>bsf</u>(uint <i>v</i>);
</big></dt>
<dd>Scans the bits in <i>v</i> starting with bit 0, looking
 for the first set bit.
<br><br>
<b>Returns:</b><br>
The bit number of the first bit set.
  The return value is undefined if <i>v</i> is zero.
     
<br><br>

</dd>
<dt><big>int <u>bsr</u>(uint <i>v</i>);
</big></dt>
<dd>Scans the bits in <i>v</i> from the most significant bit
 to the least significant bit, looking
 for the first set bit.
<br><br>
<b>Returns:</b><br>
The bit number of the first bit set.
  The return value is undefined if <i>v</i> is zero.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <font color=blue>import</font> core.bitop;

 <font color=blue>int</font> main()
 {
     <font color=blue>uint</font> <i>v</i>;
     <font color=blue>int</font> x;

     <i>v</i> = 0x21;
     x = bsf(<i>v</i>);
     printf(<font color=red>"bsf(x%x) = %d\n"</font>, <i>v</i>, x);
     x = <u>bsr</u>(<i>v</i>);
     printf(<font color=red>"bsr(x%x) = %d\n"</font>, <i>v</i>, x);
     <font color=blue>return</font> 0;
 }
</pre>
<br><br>
<b>Output:</b><br>
bsf(x21) = 0<br>
  <u>bsr</u>(x21) = 5
     
<br><br>

</dd>
<dt><big>int <u>bt</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests the bit.
     
<br><br>

</dd>
<dt><big>int <u>btc</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests and complements the bit.
     
<br><br>

</dd>
<dt><big>int <u>btr</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests and resets (sets to 0) the bit.
     
<br><br>

</dd>
<dt><big>int <u>bts</u>(uint* <i>p</i>, uint <i>bitnum</i>);
</big></dt>
<dd>Tests and sets the bit.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint* <i>p</i></td>
<td>a non-NULL pointer to an array of uints.</td></tr>
<tr><td>index</td>
<td>a bit number, starting with bit 0 of <i>p</i>[0],
 and progressing. It addresses bits like the expression:
<pre class="d_code">    <i>p</i>[index / (<font color=blue>uint</font>.sizeof*8)] &amp; (1 &lt;&lt; (index &amp; ((<font color=blue>uint</font>.sizeof*8) - 1)))
</pre>
</td></tr>
</table><br>
<b>Returns:</b><br>
A non-zero value if the bit was set, and a zero
  if it was clear.

<br><br>
<b>Example:</b><br>
<pre class="d_code">    <font color=blue>import</font> core.bitop;

    <font color=blue>int</font> main()
    {
        <font color=blue>uint</font> array[2];

        array[0] = 2;
        array[1] = 0x100;

        printf(<font color=red>"btc(array, 35) = %d\n"</font>, &lt;b&gt;btc&lt;/b&gt;(array, 35));
        printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

        printf(<font color=red>"btc(array, 35) = %d\n"</font>, &lt;b&gt;btc&lt;/b&gt;(array, 35));
        printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

        printf(<font color=red>"bts(array, 35) = %d\n"</font>, &lt;b&gt;<u>bts</u>&lt;/b&gt;(array, 35));
        printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

        printf(<font color=red>"btr(array, 35) = %d\n"</font>, &lt;b&gt;btr&lt;/b&gt;(array, 35));
        printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

        printf(<font color=red>"bt(array, 1) = %d\n"</font>, &lt;b&gt;bt&lt;/b&gt;(array, 1));
        printf(<font color=red>"array = [0]:x%x, [1]:x%x\n"</font>, array[0], array[1]);

        <font color=blue>return</font> 0;
    }
</pre>
<br><br>
<b>Output:</b><br>
<pre>
    btc(array, 35) = 0
    array = [0]:x2, [1]:x108
    btc(array, 35) = -1
    array = [0]:x2, [1]:x100
    <u>bts</u>(array, 35) = 0
    array = [0]:x2, [1]:x108
    btr(array, 35) = -1
    array = [0]:x2, [1]:x100
    bt(array, 1) = -1
    array = [0]:x2, [1]:x100
    </pre>
     
<br><br>

</dd>
<dt><big>uint <u>bswap</u>(uint <i>v</i>);
</big></dt>
<dd>Swaps bytes in a 4 byte uint end-to-end, i.e. byte 0 becomes
 byte 3, byte 1 becomes byte 2, byte 2 becomes byte 1, byte 3
 becomes byte 0.
     
<br><br>

</dd>
<dt><big>ubyte <u>inp</u>(uint <i>port_address</i>);
<br>ushort <u>inpw</u>(uint <i>port_address</i>);
<br>uint <u>inpl</u>(uint <i>port_address</i>);
</big></dt>
<dd>Reads I/O port at <i>port_address</i>.
     
<br><br>

</dd>
<dt><big>ubyte <u>outp</u>(uint <i>port_address</i>, ubyte <i>value</i>);
<br>ushort <u>outpw</u>(uint <i>port_address</i>, ushort <i>value</i>);
<br>uint <u>outpl</u>(uint <i>port_address</i>, uint <i>value</i>);
</big></dt>
<dd>Writes and returns <i>value</i> to I/O port at <i>port_address</i>.
     
<br><br>

</dd>
<dt><big>int <u>popcnt</u>(uint <i>x</i>);
</big></dt>
<dd>Calculates the number of set bits in a 32-bit integer.
 
<br><br>

</dd>
<dt><big>uint <u>bitswap</u>(uint <i>x</i>);
</big></dt>
<dd>Reverses the order of bits in a 32-bit integer.
 
<br><br>

</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright Don Clugston 2005 - 2009.
</small>
	</body></html>
