<html><head>
	<META http-equiv="content-type" content="text/html; charset=utf-8">
	<title>core.sync.semaphore</title>
	</head><body>
	<h1>core.sync.semaphore</h1>
	<!-- Generated by Ddoc from core\sync\semaphore.d -->
$(DDOC_SECTIONS 
The <u>semaphore</u> module provides a general use <u>semaphore</u> for synchronization.
<br><br>
$(DDOC_LICENSE <a href="http://www.boost.org/LICENSE_1_0.txt>Boost License 1.0</a>.
)
<b>Authors:</b><br>
Sean Kelly
<br><br>

          Copyright Sean Kelly 2005 - 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
)
<b>http:</b><br>
//www.boost.org/LICENSE_1_0.txt<br><br>
 
<br><br>
)
<dl><dt><big>class <u>Semaphore</u>;
</big></dt>
<dd>This class represents a general counting semaphore as concieved by Edsger
 Dijkstra.  As per Mesa type monitors however, "signal" has been replaced
 with "notify" to indicate that control is not transferred to the waiter when
 a notification is sent.
 
<br><br>

<dl><dt><big>this(uint <i>count</i> = 0);
</big></dt>
<dd>Initializes a semaphore object with the specified initial <i>count</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>count</i></td>
<td>The initial <i>count</i> for the semaphore.</td></tr>
</table><br>
<b>Throws:</b><br>
SyncException on error.
     
<br><br>

</dd>
<dt><big>void <u>wait</u>();
</big></dt>
<dd>Wait until the current count is above zero, then atomically decrement
 the count by one and return.
<br><br>
<b>Throws:</b><br>
SyncException on error.
     
<br><br>

</dd>
<dt><big>bool <u>wait</u>(long <i>period</i>);
</big></dt>
<dd>Suspends the calling thread until the current count moves above zero or
 until the supplied time <i>period</i> has elapsed.  If the count moves above
 zero in this interval, then atomically decrement the count by one and
 return <b>true</b>.  Otherwise, return <b>false</b>.
<br><br>
<b>Params:</b><br>
<table><tr><td>long <i>period</i></td>
<td>The time to <u>wait</u>, in 100 nanosecond intervals.  This value may
           be adjusted to equal to the maximum <u>wait</u> <i>period</i> supported by
           the target platform if it is too large.</td></tr>
</table><br>
<b>In:</b><br>
<i>period</i> must be non-negative.

<br><br>
<b>Throws:</b><br>
SyncException on error.

<br><br>
<b>Returns:</b><br>
<b>true</b> if notified before the timeout and <b>false</b> if not.
     
<br><br>

</dd>
<dt><big>void <u>notify</u>();
</big></dt>
<dd>Atomically increment the current count by one.  This will <u>notify</u> one
 waiter, if there are any in the queue.
<br><br>
<b>Throws:</b><br>
SyncException on error.
     
<br><br>

</dd>
<dt><big>bool <u>tryWait</u>();
</big></dt>
<dd>If the current count is equal to zero, return.  Otherwise, atomically
 decrement the count by one and return <b>true</b>.
<br><br>
<b>Throws:</b><br>
SyncException on error.

<br><br>
<b>Returns:</b><br>
<b>true</b> if the count was above zero and <b>false</b> if not.
     
<br><br>

</dd>
</dl>
</dd>
</dl>

	<hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright Sean Kelly 2005 - 2009.
</small>
	</body></html>
